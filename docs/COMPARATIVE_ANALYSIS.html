<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ“Š Comparative Analysis - MPMC Queue</title>
    <link rel="stylesheet" href="shared-styles.css">

</head>
<body>
    <div class="container">
        <div class="header">
            <a href="https://github.com/abbychau/mpmc-std" class="github-corner" target="_blank" rel="noopener noreferrer">
                <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 250 250" fill="#151513" style="position: absolute; top: 0; right: 0">
                <path d="M0 0l115 115h15l12 27 108 108V0z" fill="#000"/>
                <path class="octo-arm" d="M128 109c-15-9-9-19-9-19 3-7 2-11 2-11-1-7 3-2 3-2 4 5 2 11 2 11-3 10 5 15 9 16" style="-webkit-transform-origin: 130px 106px; transform-origin: 130px 106px"/>
                <path class="octo-body" d="M115 115s4 2 5 0l14-14c3-2 6-3 8-3-8-11-15-24 2-41 5-5 10-7 16-7 1-2 3-7 12-11 0 0 5 3 7 16 4 2 8 5 12 9s7 8 9 12c14 3 17 7 17 7-4 8-9 11-11 11 0 6-2 11-7 16-16 16-30 10-41 2 0 3-1 7-5 11l-12 11c-1 1 1 5 1 5z"/>
                </svg>
            </a>
            <h1>ğŸ“Š Comparative Analysis</h1>
            <p>Performance comparison with industry-standard queue implementations</p>
        </div>
        
        <div class="content">
            <div style="text-align: center; margin-bottom: 2rem;">
                <a href="index.html" class="nav-back">â† Back to Documentation Index</a>
            </div>
<h1>Algorithmic Analysis: mpmc-std Design Principles</h1>
<p>This document examines the algorithmic foundations of <code>mpmc-std</code> compared to established queue implementations, focusing on design trade-offs and architectural differences rather than performance claims.</p>
<h2>Algorithmic Approaches Overview</h2>
<h3>Memory Layout Comparison</h3>
<pre><code>
LMAX Disruptor (Ring Buffer):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚  0  â”‚  1  â”‚  2  â”‚  3  â”‚  4  â”‚  5  â”‚  6  â”‚  7  â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
      â†‘                               â†‘
   Producer                       Consumer
   Sequence                       Sequence
Michael &amp; Scott (Linked Nodes):
Head â†’ [Node] â†’ [Node] â†’ [Node] â†’ [Node] â†’ Tail
       â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”
       â”‚Data â”‚   â”‚Data â”‚   â”‚Data â”‚   â”‚Data â”‚
       â”‚Next*â”‚   â”‚Next*â”‚   â”‚Next*â”‚   â”‚Next*â”‚
       â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜
mpmc-std (Sequence-Coordinated Array):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ S:0 â”‚ S:1 â”‚ S:2 â”‚ S:3 â”‚ S:4 â”‚ S:5 â”‚ S:6 â”‚ S:7 â”‚
â”‚ [D] â”‚ [D] â”‚ [D] â”‚ [D] â”‚ [D] â”‚ [D] â”‚ [D] â”‚ [D] â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
S = Sequence Number, D = Data Slot
</code></pre>
<h2>Core Algorithmic Differences</h2>
<h3>1. LMAX Disruptor Algorithm</h3>
<p><strong>Core Principle</strong>: Ring buffer with sequence barriers and memory barriers for coordination.</p>
<br>
<pre><code>
Algorithm: Disruptor Send
1. claim_slot = next_sequence++
2. wait_for_slot_available(claim_slot)
3. write_data_to_slot(claim_slot)
4. publish_sequence(claim_slot)
5. notify_consumers()
Memory Barriers:
- Store-Store before publish
- Load-Acquire for dependency tracking
- Complex barrier coordination for multiple consumers
</code></pre>
<br>
<p><strong>Key Characteristics</strong>:</p>
<ul>
<li><strong>Coordination</strong>: Complex sequence barriers and dependency chains</li>
<li><strong>Memory Management</strong>: Pre-allocated ring buffer</li>
<li><strong>Ordering</strong>: Strong ordering guarantees with memory barriers</li>
<li><strong>Complexity</strong>: Multiple sequence types (producer, consumer, gating)</li>
</ul>
<h3>2. Michael & Scott Algorithm</h3>
<p><strong>Core Principle</strong>: Lock-free linked list with atomic compare-and-swap on head/tail pointers.</p>
<br>
<pre><code>
Algorithm: Michael &amp; Scott Enqueue
1. node = allocate_new_node(data)
2. loop:
3.   tail = load_tail()
4.   next = load_tail_next() 
5.   if tail == current_tail:
6.     if next == null:
7.       if CAS(tail.next, null, node):
8.         break
9.     else:
10.      CAS(tail_ptr, tail, next)  // Help move tail
11. CAS(tail_ptr, tail, node)
Memory Pattern:
- Dynamic allocation per operation
- Pointer chasing through linked structure
- ABA problem mitigation required
</code></pre>
<br>
<p><strong>Key Characteristics</strong>:</p>
<ul>
<li><strong>Coordination</strong>: Atomic pointer manipulation with helping protocol</li>
<li><strong>Memory Management</strong>: Dynamic allocation per enqueue/dequeue</li>
<li><strong>Ordering</strong>: Natural FIFO through linked structure</li>
<li><strong>Complexity</strong>: ABA problem handling, memory reclamation</li>
</ul>
<h3>3. mpmc-std Algorithm</h3>
<p><strong>Core Principle</strong>: Array slots with per-slot sequence numbers for coordination.</p>
<br>
<pre><code>
Algorithm: mpmc-std Send
1. pos = head.fetch_add(1, Relaxed)
2. slot = &amp;buffer[pos &amp; mask]
3. while slot.sequence.load(Acquire) != pos:
4.   spin_loop_hint()
5. slot.item.write(data)
6. slot.sequence.store(pos + 1, Release)
Sequence States:
- slot.sequence == pos     â†’ Ready for producer
- slot.sequence == pos + 1 â†’ Data available for consumer  
- slot.sequence == pos + N â†’ Consumed, waiting for wraparound
</code></pre>
<br>
<p><strong>Key Characteristics</strong>:</p>
<ul>
<li><strong>Coordination</strong>: Per-slot sequence matching</li>
<li><strong>Memory Management</strong>: Fixed pre-allocated array</li>
<li><strong>Ordering</strong>: Mathematical sequence progression</li>
<li><strong>Complexity</strong>: Simple slot state machine</li>
</ul>
<h2>Detailed Algorithmic Analysis</h2>
<h3>Coordination Mechanisms</h3>
<h4>Disruptor: Barrier-Based Coordination</h4>
<pre><code>
Producer Barriers:     Consumer Barriers:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Claim Sequence  â”‚   â”‚ Wait for Data   â”‚
â”‚ Wait for Space  â”‚   â”‚ Process Batch   â”‚
â”‚ Write Data      â”‚   â”‚ Update Cursor   â”‚
â”‚ Publish Batch   â”‚   â”‚ Signal Complete â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                       â”‚
        â””â”€â”€â”€â”€ Memory Barriers â”€â”€â”˜
</code></pre>
<h4>mpmc-std: Sequence Matching</h4>
<pre><code>
Producer Flow:              Consumer Flow:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Get Position    â”‚        â”‚ Get Position    â”‚
â”‚ Wait for Slot   â”‚ â†---â†’  â”‚ Wait for Data   â”‚
â”‚ Write Data      â”‚        â”‚ Read Data       â”‚
â”‚ Release Slot    â”‚        â”‚ Release Slot    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2>Comparison Summary Table</h2>
<table><thead><tr><th>Feature</th><th>LMAX Disruptor</th><th>Michael & Scott</th><th>mpmc-std</th><th>mpmc-std SIMD</th></tr></thead><tbody><tr><td><strong>Coordination</strong></td><td>Sequence barriers</td><td>Atomic pointer ops</td><td>Per-slot sequence</td><td>Vectorized sequences</td></tr><tr><td><strong>Memory Layout</strong></td><td>Ring buffer</td><td>Linked nodes</td><td>Fixed array</td><td>SIMD-aligned array</td></tr><tr><td><strong>Memory Management</strong></td><td>Pre-allocated</td><td>Dynamic allocation</td><td>Pre-allocated</td><td>Pre-allocated</td></tr><tr><td><strong>Ordering</strong></td><td>Strong (barriers)</td><td>FIFO (linked list)</td><td>Mathematical sequence</td><td>Mathematical sequence</td></tr><tr><td><strong>Complexity</strong></td><td>High (multiple seqs)</td><td>Medium (ABA, helping)</td><td>Low (slot state)</td><td>Low (vectorized)</td></tr><tr><td><strong>Scalability</strong></td><td>High (batch, barriers)</td><td>High (lock-free)</td><td>High (lock-free)</td><td>Higher (SIMD batches)</td></tr><tr><td><strong>ABA Handling</strong></td><td>Not required</td><td>Required</td><td>Not required</td><td>Not required</td></tr><tr><td><strong>Producer/Consumer</strong></td><td>Multiple</td><td>Multiple</td><td>Multiple</td><td>Multiple</td></tr><tr><td><strong>Data Types</strong></td><td>Generic</td><td>Generic</td><td>Generic</td><td>u64 optimized</td></tr><tr><td><strong>Batch Operations</strong></td><td>Optional</td><td>No</td><td>No</td><td>Yes (4x u64)</td></tr><tr><td><strong>Typical Use Case</strong></td><td>Low-latency trading</td><td>General-purpose queues</td><td>General-purpose</td><td>Numeric workloads</td></tr></tbody></table>
<h2>SIMD Algorithm Extension</h2>
<p>The mpmc-std SIMD variant extends the basic algorithm with vectorized operations for u64 data types.</p>
<h3>SIMD Coordination Algorithm</h3>
<pre><code>
Traditional Slot Check (4 operations):
for i in 0..4:
    if slot[i].sequence == expected[i]:  // 4 separate checks
        slot_available[i] = true
SIMD Slot Check (1 vectorized operation):
sequences = [slot[0].seq, slot[1].seq, slot[2].seq, slot[3].seq]  // Load 4 sequences
expected  = [head+0, head+1, head+2, head+3]                    // Generate expected
mask = simd_eq(sequences, expected)                              // Compare all at once
if mask.all():                                                   // All slots ready
    claim_batch()
</code></pre>
<h3>SIMD vs Traditional Performance Profile</h3>
<p><strong>Memory Access Pattern:</strong></p>
<pre><code>
Traditional: 4 separate loads + 4 separate comparisons + 4 branches
SIMD:        1 vectorized load + 1 vectorized compare + 1 branch
</code></pre>
<br>
<p><strong>Theoretical Performance Gain:</strong></p>
<ul>
<li><strong>Memory</strong>: 4x fewer load operations (vectorized)</li>
<li><strong>ALU</strong>: 4x fewer comparison operations (parallel)</li>
<li><strong>Branch</strong>: 4x fewer conditional branches</li>
<li><strong>Cache</strong>: Better spatial locality with vectorized access</li>
</ul>
<br>
<p><strong>Real-World Results:</strong></p>
<ul>
<li>Single-threaded: 10-30% improvement</li>
<li>High-contention: Up to 1.8x speedup (4+ thread pairs)</li>
<li>Optimal workload: u64 numeric processing in 4-element batches</li>
</ul>
<h3>SIMD Algorithmic Trade-offs</h3>
<p><strong>Advantages:</strong></p>
<ul>
<li>Vectorized sequence checking reduces instruction count</li>
<li>Better CPU pipeline utilization</li>
<li>Improved cache efficiency for batch operations</li>
<li>Maintains all lockless guarantees</li>
</ul>
<br>
<p><strong>Limitations:</strong></p>
<ul>
<li>Requires nightly Rust (unstable portable_simd)</li>
<li>Limited to u64 data types</li>
<li>Minimum capacity requirements (16+ elements)</li>
<li>Best performance only with 4-aligned batch sizes</li>
</ul>
<br>
<p><strong>Use Case Optimization:</strong></p>
<pre><code class="language-rust">
// Optimal: Numeric processing with known batch sizes
let numeric_data: Vec&lt;u64&gt; = sensor_readings();
simd_queue.send_batch(&amp;numeric_data[0..4])?;
// Suboptimal: Mixed types or variable sizes  
let mixed_data: Vec&lt;String&gt; = user_messages();
regular_queue.send(mixed_data[0].clone())?;  // Better choice
</code></pre>
<br>
<br>
        </div>
        
        <div class="nav-grid">
            <div class="nav-card">
                <p>Explore the complete technical documentation suite for the MPMC Queue implementation.</p>
                <div style="display: flex; gap: 1rem; margin-top: 1.5rem;">
                    <a href="index.html" style="flex: 1; text-align: center;">Documentation Index</a>
                    <a href="COMPARATIVE_ANALYSIS.html" style="flex: 1; text-align: center;">Comparative Analysis</a>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <div class="footer-brand">MPMC Queue - High-Performance Lockless Data Structure</div>
        <p>Built with Rust â€¢ Benchmarked with Criterion.rs â€¢ Optimized for Modern Hardware</p>
        <p style="font-size: 0.9rem; margin-top: 1rem;">
            Research-grade implementation combining Michael & Scott, LMAX Disruptor, and modern optimization techniques
        </p>
    </div>
</body>
</html>
